# Данные считываются с тестовых файлов, названия которых надо указать в первых двух строках программы.
# Функция min_len осуществляет подбор длины отрезка при заданных точках и количестве отрезков.
# Данная функция запускает бесконечный цикл while, который вызывает фунцию check, пердавая ей проверяемую длину отрезка.
# Функция check возвращает результат, указывающий на необходимость увеличения или уменьшения длины отрезка.
# В зависимости от полученного результата в while производится соответствующая корректировка длины отрезка,
# после чего опять запускается фунция check.
# Если после корректировки длина не изменяется, это значит, что бинарный поиск пришёл к нужному результату,
# и данная длина выдаётся как результат работы программы.
# Посе этого производится сравнение результата работы программы и правильного ответа из файла .out
# результат сравнения выводится в консоль как "true" или "false"


file_in = open('1.in')  # файл с данными задачи
file_out = open('1.out')  # файл с правильным ответом

correct_answer = int(file_out.readline())

N = int(file_in.readline())
k = int(file_in.readline())
list_numbers = []

for i in range(0, N):  # считывае точек из файла и добавление их в список
    list_numbers.append(int(file_in.readline()))

# функция поиска длины отрезка
def min_len(N, k, list_numbers):
    #print(N)
    #print(k)
    #print(list_numbers)

    if (k >= N):  # если количество отрезков не меньше количества точек
        return 0

    if (k == 1):  # если дан один отрезок
        return list_numbers[-1] - list_numbers[0]

    # функция проверки отрезка заданной длины
    def check(middle):
        #print("Функция_чек, длина = ", middle)
        all_points_include = False
        first_not_include = 0  # первая невошедшая точка при данной длине отрезка и номере отрезка

        # для и-того отрезка
        for i in range(0, k):  # отрезки от первого до последнего без исключений
            #print("чек к", "Отрезок № = ", i, "Первая невошедшая № ", first_not_include, " = ", list_numbers[first_not_include])

            # для жи-той точки
            for j in range(first_not_include, N):
                #print("чек Н, проверяем точку № ", j, " = (", list_numbers[j], ")")
                if (list_numbers[first_not_include] + middle < list_numbers[j]):  # если нашли первую невошедшую точку
                    #print("!!! Нашли первую невошедшую ", j, " = (", list_numbers[j], ")")
                    first_not_include = j
                    break  # завершаем цикл по жи и переходим к следующему отрезку

                if (list_numbers[first_not_include] + middle >= list_numbers[-1]):  # если и-тый отрезок накрыл последнюю точку
                    #print("ДОСТАЛИ ДО ПОСЛЕДНЕЙ")
                    all_points_include = True  # если невошедших больше нет

        if (all_points_include == True):
            return 1  # достали до последней точки, можно попробовать сократить длину
        else:
            return 2  # не достали до последней точки, надо увеличивать длину

    #  левые и правые края для выбора середины
    left = 1
    right = list_numbers[-1] - list_numbers[0]
    middle = int((left + right) / 2)  # середина диапазона и длина отрезка

    previous_middle = 0  # переменная для хранения предыдущей проверяемой длины

    while True:  # бесконечный цикл для корректировки длины отрезка
        # print("while", "ДЛИНА = ", middle, "левый = ", left, "правый = ", right)
        check_result = check(middle)  # вызов фукции проверки для заданной длины

        if (check_result == 1):  # функция проверки заданной длины указывает, что надо сокращать длину
            # print("надо сокращать")
            if (middle == 1):  # нет смысла сокращать длину, которая равна единице
                return middle
            previous_middle = middle
            right = middle
            middle = int((left + right) / 2)

            # если после корректировки длины она не меняется, то данная длина является ответом задачи
            if (previous_middle == middle):
                return middle

        if (check_result == 2):  # функция проверки заданной длины указывает, что надо увеличивать длину
            # print("надо удлинять")
            previous_middle = middle
            left = middle
            middle = int((left + right) / 2)

            # если после корректировки длины она не меняется, то данная длина является ответом задачи
            # с учётом увеличения на 1, т.к. функция int() округляет всегда в менбшую сторону
            if (previous_middle == middle):
                return middle + 1


result = min_len(N, k, list_numbers)  # вызов функции
print(result)  # вывод результата

if (result == correct_answer):  # сверка полученного результата и вывод ответа о правильности
    print("True")
else:
    print("False")
